package mun.concurrent.assignment.two;

import java.util.ArrayList;
import java.lang.*;
import java.util.List;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class ElevatorArray implements Runnable {
    List<Elevator> elevators = new ArrayList<>();
    List<Rider> riders = new ArrayList<>();
    int numElevators;
    ReentrantLock elevatorLock; // TODO: should this be static?
    Condition riderAdded;
    boolean mainEnded;
    ReentrantLock elevatorClockLock;
    Condition elevatorClockTicked;
    static Clock SimulationClock;
    static ElevatorSimulator simulator;

    public ElevatorArray (int numElevators, int capacity, ReentrantLock elevatorLock, Condition riderAdded, boolean mainEnded,
                          ReentrantLock elevatorClockLock, Condition elevatorClockTicked, Clock simulationClock, ElevatorSimulator simulator){

        this.numElevators= numElevators;
        this.elevatorLock = elevatorLock;
        this.riderAdded = riderAdded;
        this.mainEnded = mainEnded;
        this.elevatorClockLock = elevatorClockLock;
        this.elevatorClockTicked = elevatorClockTicked;
        SimulationClock = simulationClock;
        this.simulator = simulator; 

        // Create elevators
        for(int i = 0; i < numElevators; i++) {
            elevators.add( new Elevator(capacity, 0, 1, i));
        }

    }

    public ElevatorArray(){

    }

    public void addRiderToRiders(Rider rider) {
        elevatorLock.lock();

        riders.add(rider);
        riderAdded.signalAll();

        elevatorLock.unlock();
    }

    // Assigns an elevator to a rider generated by Factory
    public Elevator assignElevatorToRider(Rider rider){
        Status direction;

        //Find direction
        if (rider.dest_floor - rider.start_floor > 0){
            direction = Status.UP;
        }
        else{
            direction = Status.DOWN;
        }

        //Find elevators with status stationary AND same direction
        ArrayList<Integer> eligibleElevators = new ArrayList<>();
        for (int i = 0; i<numElevators; i++){
            Elevator elevator = elevators.get(i);
            if (elevator.getStatus() == Status.STATIONARY){
                eligibleElevators.add(i);
            }
            else if (elevator.getStatus() == direction){
                if(direction == Status.UP){
                    if(elevator.getCurrentFloor() < rider.start_floor){
                        eligibleElevators.add(i);
                    }
                }
                else if (direction == Status.DOWN){
                    if(elevator.getCurrentFloor() > rider.start_floor){
                        eligibleElevators.add(i);
                    }
                }
            }
        }

        // Find |elevator.current_floor - rider.start_floor|
        int min_difference = 5; // since maximum difference is 4
        int current_difference;
        int index=0;
        for (int i = 0; i< eligibleElevators.size(); i++) {
            current_difference = Math.abs(elevators.get(eligibleElevators.get(i)).getCurrentFloor() - rider.start_floor);
            if(current_difference < min_difference){
                min_difference = current_difference;
                index = eligibleElevators.get(i);
            }
        }

        System.out.println("Chosen elevator is elevator " + index + ". current floor: " + elevators.get(index).getCurrentFloor());
        return elevators.get(index);
    }


    public void run(){
        // move the elevator there

        // but problem here is how to know which elevator has the rider added

        System.out.println("Starting: " +  Thread.currentThread().getName());

        Elevator elevator = new Elevator();
        boolean elevatorShouldMove = false;
        while(!mainEnded) {
            try {
                elevatorLock.lockInterruptibly();
                riderAdded.await(); // should this be a semaphore?
                if (riders.size() != 0) {

                    Rider rider = riders.get(0);

                    elevator = assignElevatorToRider(rider);
                    elevator.addRiderToElevQueue(rider);

                    // Find the elev current floor
                    int riderTravelTime = Math.abs(rider.start_floor - rider.dest_floor) * 5 + 30; // +30 for pickup and dropoff
                    int elevatorOnlyTravelTime = Math.abs(elevator.getCurrentFloor() - rider.start_floor) * 5;
                    simulator.ridersTime += riderTravelTime+elevatorOnlyTravelTime;

                    riders.remove(rider);
                    elevatorShouldMove = true;
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                elevatorLock.unlock();
            }

            // TODO: make this in a good way. It is this way because dont want to keep locked while elev moves
            if(elevatorShouldMove){
                try {
                    moveElevator(elevator, elevatorShouldMove);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

        }

    }

    public void moveElevator(Elevator elevator, boolean elevatorShouldMove) throws InterruptedException {
        System.out.println("The elevator will pick up from floor: " + elevator.getElevatorQueue().get(0) + " And drop off at floor: " + elevator.getDropoffQueue().get(0));

        // while there exists destinations on the queue
        while(elevator.getElevatorQueue().size() > 0){
            System.out.println("current thread: " + Thread.currentThread().getName());

            // Set status based on direction
            elevator.setStatusUpDown();

            // read current tick
            int currentTime = getCurrentTime();

            // Go to that floor.
            while( ( elevator.getCurrentFloor() != elevator.getElevatorQueue().get(0) )){
                if (simulator.mainEnded){
                    Thread.currentThread().interrupt();
                }

                // Lock and check if 5 seconds have passed, if so update floor.
                elevatorClockLock.lockInterruptibly();
                int newCurrentTime = SimulationClock.getTick();
                System.out.println("Elevator " + elevator.getElevatorIndex() + " moving. Current time: " + newCurrentTime + " current floor: " + elevator.getCurrentFloor() + " Destination floor: " + elevator.getElevatorQueue().get(0));

                if (newCurrentTime >= currentTime + 5){ // ideally should be ==
                    elevator.updateFloor();
                    currentTime = newCurrentTime;
                }

                elevatorClockLock.unlock();
                Thread.sleep(15);
            }

            // Drop off rider (or 2 riders) if current floor contained in dropOff_queue
            elevator.dropOffRider();

            // Increment count if current floor remains on elevator_queue after potentially removing rider above
            boolean pickedUp = elevator.pickUpRider();
            if (!pickedUp){
                simulator.rejects++; //TODO: this is not ideal
            }
            // Set status to stationary temporarily while elevator waits 15 seconds
            elevator.setStatusStationary();
            if (elevator.getElevatorQueue().size() > 0){
                elevator.setStatusDoorsOpen();
            }

            // Wait 15 seconds
            int doorClosedTime = currentTime + 15;
            currentTime = getTick();
            while ( (currentTime < doorClosedTime)){ // "Less than" is used instead of "!=" in case clock ticked twice
                if (simulator.mainEnded){
                    Thread.currentThread().interrupt();
                }
                currentTime = getTick();
//                System.out.println("waiting to reach 15s");
                Thread.sleep(15);
            }

            System.out.println("Elevator " + elevator.getElevatorIndex() +": 15 seconds has passed by for rider to get in or out");
        }
        elevatorShouldMove = false;
    } // end method run

    private int getTick() throws InterruptedException {
        int currentTime;
        elevatorClockLock.lockInterruptibly();

        try {
            currentTime = SimulationClock.getTick();
        } finally {
            elevatorClockLock.unlock();
        }
        return currentTime;
    }

    private int getCurrentTime() throws InterruptedException {
        elevatorClockLock.lockInterruptibly();
        int currentTime = SimulationClock.getTick();
        elevatorClockTicked.signalAll();
        elevatorClockLock.unlock();
        return currentTime;
    }


}
